通过三级缓存的定义可以看到，其实它们本质上就是一个 Map。接下来让我们看一下他们的具体作用
1. **singletonObjects 是一级缓存，也被称作单例池，它存储的是已经创建好的完整的 bean 对象**。在创建一个单例 bean 时，会优先从单例池中尝试获取该 bean 的实例，如果能够获取到则直接返回;如果获取不到则继续创建该单例 bean。
2. **earlySingletonObjects 是二级缓存，存储的是尚未完全创建好的单例 bean 对象**。在创建单例 bean 时，如果发现该 bean 存在循环依赖，则会先创建该 bean 的"半成品"对象，并放入到二级缓存中。如果该 bean 需要进行 AOP，则该"半成品"对象是它的代理对象，否则就是它实例化之后但是尚未属性填充的原始对象。
3. **singletonFactories 是三级缓存，存储的是单例 bean 的创建工厂，其实就是一个 Lambda 表达式**。在每个bean 的创建过程中经过实例化得到一个原始对象后，都会提前基于该原始对象暴露一个 Lambda 表达式，并保存到三级缓存中。这个 Lambda 表达式可能会用到，也可能用不到，主要取决于当前 bean 是否存在循环依赖。如果当前 bean 没有出现循环依赖，那么这个 Lambda表达式就不会被用到，当前 bean 会按照自己的生命周期正常执行，创建完成后会被放入到单例池中;如果当前 bean 在依赖注入时出现了循环依赖，则会从三级缓存中取出 Lambda 表达式并执行，执行返回的对象会被放入到二级缓存。