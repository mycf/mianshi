限流：对应用服务器的请求做限制，避免因过多请求而导致服务器过载甚至宕机。

限流算法常见的包括两种:
1. 计数器算法，又包括窗口计数器算法、滑动窗口计数器算法
2. 令牌桶算法(Token Bucket)
3. 漏桶算法(Leaky Bucket)

固定窗口计数器算法
固定窗口计数器算法概念如下:
- 将时间划分为多个窗口，窗口时间跨度称为Interval，本例中为1000ms;
- 每个窗口维护一个计数器，每有一次请求就将计数器加一，限流就是设置计数器阈值，本例为3
- 如果计数器超过了限流阈值，则超出阈值的请求都被丢弃。

滑动窗口计数器算法
滑动窗口计数器算法会将一个窗口划分为n个更小的区间，例如
窗口时间跨度Interval为1秒;区间数量n=2，则每个小区间时间跨度为500ms限流阈值依然为3，时间窗口(1秒)内请求超过阈值时，超出的请求被限流
窗口会根据当前请求所在时间(currentTime)移动，窗口范围是从(currentTime-Interval)之后的第一个
时区开始，到currentTime所在时区结束。

# 令牌桶算法
令牌桶算法说明:
以固定的速率生成令牌，存入令牌桶中，如果令牌桶满了以后，多余令牌丢弃请求进入后，必须先尝试从桶中获取令牌，获取到令牌后才可以被处理如果令牌桶中没有令牌，则请求等待或丢弃

- KEYS[1]：hash key name
- KEYS[2]：全局 string(value) key name
- KEYS[3]：单机 string(value) key name
- KEYS[4]：全局 zset(permits) key name
- KEYS[5]：单机 zset(permits) key name
- ARGV[1]：当前请求令牌数量
- ARGV[2]：当前时间
- ARGV[3]：8位随机字符串
```lua
-- rate：间隔时间内产生令牌数量
-- interval：间隔时间
-- type：类型：0-全局限流；1-单机限流
local rate = redis.call('hget', KEYS[1], 'rate');
local interval = redis.call('hget', KEYS[1], 'interval');
local type = redis.call('hget', KEYS[1], 'type');
-- 如果3个参数存在空值，错误提示初始化未完成
assert(rate ~= false and interval ~= false and type ~= false, 'RateLimiter is not initialized')
local valueName = KEYS[2];
local permitsName = KEYS[4];
-- 如果是单机限流，在全局key后拼接上机器唯一标识字符
if type == '1' then
    valueName = KEYS[3];
    permitsName = KEYS[5];
end ;
-- 如果：当前请求令牌数 > 窗口时间内令牌产生数量，错误提示请求令牌不能超过rate
assert(tonumber(rate) >= tonumber(ARGV[1]), 'Requested permits amount could not exceed defined rate');
-- currentValue = 当前剩余令牌数量
local currentValue = redis.call('get', valueName);
-- 非第一次访问，存储剩余令牌数量的 key 存在，有值（包括 0）
if currentValue ~= false then
    -- 当前时间戳往前推一个间隔时间，属于时间窗口以外。
    -- 时间窗口以外，签发过的令牌，都属于过期令牌，需要回收回来
    local expiredValues = redis.call('zrangebyscore', permitsName, 0, tonumber(ARGV[2]) - interval);
    -- 统计可以回收的令牌数量
    local released = 0;
    for i, v in ipairs(expiredValues) do
        -- lua struct的pack/unpack方法，可以理解为文本压缩/解压缩方法
        local random, permits = struct.unpack('fI', v);
        released = released + permits;
    end ;
    -- 移除 zset(permits) 中过期的令牌签发记录
    -- 将过期令牌回收回来，重新更新剩余令牌数量
    if released > 0 then
        redis.call('zremrangebyscore', permitsName, 0, tonumber(ARGV[2]) - interval);
        currentValue = tonumber(currentValue) + released;
        redis.call('set', valueName, currentValue);
    end ;
    -- 如果 剩余令牌数量 < 当前请求令牌数量，返回推测可以获得所需令牌数量的时间
    -- （1）最近一次签发令牌的释放时间 = 最近一次签发令牌的签发时间戳 + 间隔时间(interval)
    -- （2）推测可获得所需令牌数量的时间 = 最近一次签发令牌的释放时间 - 当前时间戳
    -- （3）"推测"可获得所需令牌数量的时间，"推测"，是因为不确定最近一次签发令牌数量释放后，加上到时候的剩余令牌数量，是否满足所需令牌数量
    if tonumber(currentValue) < tonumber(ARGV[1]) then
        local nearest = redis.call('zrangebyscore', permitsName, '(' .. (tonumber(ARGV[2]) - interval), '+inf', 'withscores', 'limit', 0, 1);
        return tonumber(nearest[2]) - (tonumber(ARGV[2]) - interval);
        -- 如果 剩余令牌数量 >= 当前请求令牌数量，可直接记录签发令牌，并从剩余令牌数量中减去当前签发令牌数量
    else
        redis.call('zadd', permitsName, ARGV[2], struct.pack('fI', ARGV[3], ARGV[1]));
        redis.call('decrby', valueName, ARGV[1]);
        return nil;
    end ;
    -- 第一次访问，存储剩余令牌数量的 string(value) key 不存在，为 null，走初始化逻辑
else
    redis.call('set', valueName, rate);
    redis.call('zadd', permitsName, ARGV[2], struct.pack('fI', ARGV[3], ARGV[1]));
    redis.call('decrby', valueName, ARGV[1]);
    return nil;
end ;
```