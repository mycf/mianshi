![[BlockingQueue 2023-12-27 22.33.30.excalidraw|1000]]
当队列是空的，从队列中获取元素的操作将会被阻塞。
当队列是满的，从队列中添加元素的操作将会被阻塞。
试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素。
试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增。

后进先出( LIFO ): 后插入队列的元素最先出队列，这种队列优先处理最近发生的事件(栈)。
在多线程领域:所谓阻塞，在某些情况下会挂起线程(即阻塞)，一旦条件满足，被挂起的线程又会自动被唤起。

为什么需要 BlockingQueue
好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue 都给你 手包办了
在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。
# 常见的BlockingQueue
1、ArrayBlockingQueue

2、LinkedBlockingQueue
基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，其内部也维持着个数据缓冲队列( ==该队列由一个链表构成== )，当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回:只有当队列缓冲区达到最大值缓存容量时 ( LinkedBlockingQueue 可以通过构造函数指定该值)，才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。

==一句话总结: 由链表结构组成的有界( 但大小默认值为integer.MAX VALUE)阻塞队列。==
