我认为这个问题的核心本质是JDK，动态代理本身的机制来决定的，首先在java里面，动态代理是通过Proxy.newProxyInstance这个方法来实现的，它需要传入被动态代理的一个接口类，之所以要传入接口，而不能传入内啊，还是取决于GDK动态代理的一个底层实现，Jdk，动态代理会在程序的运行期间，去动态生成一个代理类 $Proxy0，那么这个动态生成代理类会去继承 java.lang.reflect.Proxy，同时还会去实现被代理类的接口，在java是不支持多继承的，而每个动态代理类都继承了一个 Proxy，所以就导致了JDK里面的动态代理，只能代理接口，而不能代理实现类，Proxy类只是保存了动态代理的处理器，叫 InvocationHandler，如果不抽出来直接设置到 $Proxy0，这个动态代理类里面也是可以的，如果这么去实现的话呢，就可以针对实现类来做动态代理了，作者为什么这么设计，我认为还是有几个方面的原因，第一个是动态代理本身的使用场景或者需求呢，只是对原始实现了一个拦截，然后去做一些功能的增强或者扩展，而实际的开发模式都是基于面向接口来开发的，所以基于接口来实现动态代理，从需求和场景都是吻合的，当然确实可能会存在一些，没有实现接口的一些类，那么这个时候我们要去实现动态代理，那么JDK很显然是无法满足的，第二个在java里面类的继承关系的设计，更多的是考虑到共性能力的抽象，从而去提高代码的重用性和扩展性，而动态代理其实也在做这样一个事情，它封装了动态代理类的深层的抽象逻辑，以及判断一个类是否是动态代理类，以及 InvocationHandler 的一个持有等等，那么我们去把这些抽象的公共逻辑，放在 Proxy 这个父类里面，很显然也是一个比较正常的一个设计思路，所以总的来说呢，我认为这个设计上，并没有什么值得特别去讨论的地方，因为我认为技术的方案的设计，是解决特定的场景问题的，如果一定要去针对普通类来去做动态代理，我们可以选择Cglib这样的一个组件，它会动态生成一个被代理类的子类，子类重写父类的所有非凡力修饰的方法，在子类中去拦截父类的所有方法的调用，从而去实现动态代理
