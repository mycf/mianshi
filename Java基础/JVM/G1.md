# 介绍
G1(Garbage-First)是一款可以指定最大停顿时间、基于 Region 的内存布局、按收益动态确定回收集的多线程并发收集
器。在满足GC停顿时间要求的同时，还具备高吞吐量性能特征。官方称之为"全功能垃圾收集器";
它从 JDK 7 开始推出，JDK 9 作为默认的垃圾收集器。

# 关于 G1 的内存布局，总结以下几点：
1. 把连续的 Java 堆划分为多个大小相等的独立区域（**Region**），默认最多可以有 2048个 Region;
2. Region 的大小可以通过参数 -XX:G1HeapRegionSize 设置，取值范围是 1~32 MB 且应为 2 的 N 次幂；
3. 每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor空间，或者老年代空间。
4. Region 中还有一类特殊的 Humongous 区域，专门用来存储大小超过Region大小的 50%的对象;5.对于超过整个 Region 容量大小的超级大对象，将会存放在 N 个连续的 Humongous 区域。

# 垃圾收集分类
G1 收集器的垃圾收集分为三种：YoungGC、MixedGC 和 FuIIGC。
## YoungGC
- ==回收对象:新生代的 Region 区域。==
- YoungGC 并不是说现有的 Eden区放满了就会马上触发；
- G1 收集器会计算下现在 Eden区 回收大概需要的时间，如果回收时间远远小于参数-XX:MaxGCPauseMills 设定的值，那么增加年轻代的 region，继续给新对象存放，不会马上做 Young GC。
- 直到下一次 Eden区 放满，G1 计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么才会触发Young GC。

## MixedGC
- ==回收对象：新生代+部分老年代(根据期望的GC停顿时间确定回收收益最大的Old区域) + 大对象区域。==
- 触发的条件：老年代的堆占有率 达到 参数(-XX:lnitiatingHeapOccupancyPercent)设定的值
- 主要使用标记-复制算法，需要把各个 region 中存活的对象拷贝到别的region里去，拷贝过程如果发现没有足够的 Region 区域能够承载拷贝对象，就会触发一次 Full GC；

## FullGC
- ==回收对象：全堆扫描，所有区域。==
- 停止系统程序;
- 采用单线程进行标记、清理和压缩整理，JDK10 开始采用多线程;
- 主要是为了能够空闲出来一批 Region 来供下次 MixedGC 使用，这个过程是非常耗时的;

# GC过程
G1 收集器的 GC 过程大致分为以下几个步骤:
- 初始标记(initial mark，STW):暂停所有的其他线程，并记录下GC Roots直接能引用的对象速度很快;。
- 并发标记(Concurrent Marking)：从GCoots 开始对堆中对象进行可达性分析，与用户线程并发执行；
- 最终标记(Remark，STW):处理并发标记介段遗留下来的少量的 原始快照(STAB) 的记录;
- 筛选回收(Cleanup，STW):首先对各个Region 的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回可收集，然后把决定回收的那一部分 Region的存活对象复制到空的 Region 中，可以自由选择任意多个 Region 构成会收集，在清理掉整个旧 Region 的全部空间。因为这里的操作涉及存活对象的移动，所以需要 STW
