![[垃圾收集器 2024-01-01 11.19.51.excalidraw]]
# Parallel Scavenge收集器

Parallel Scavenge收集器是一款**新生代**收集器，它同样是基于**标记-复制**算法实现的收集器，也是能够并行收集的多线程收集器。
Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。

吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值，即：
$$吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}$$
# Parallel Old收集器
Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于**标记-整理**算法实现。

在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。

在并行、串行以及CMS中针对堆空间的管理方式都是连续的
# CMS（Concurrent Mark Sweep）收集器
CMS（Concurrent Mark Sweep）收集器是一种以==获取最短回收停顿时间为目标==的收集器。
适合重视服务的响应速度，希望系统停顿时间最短，这类应用。

CMS收集器是基于“==标记—清除==”算法实现的，整个过程分为4个步骤，包括：
- 初始标记（CMS initial mark）
- 并发标记（CMS concurrent mark）
- 重新标记（CMS remark）
- 并发清除（CMS concurrent sweep）
初始标记、重新标记需要“Stop The World”
初始标记是标记一下GC Roots能直接关联到的对象，速度很快
并发标记阶段是进行GC Roots Tracing的过程
重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，==CMS收集器的内存回收过程是与用户线程一起并发执行的。==

CMS的缺点：
CMS收集器对CPU资源非常敏感。
CMS收集器无法处理浮动垃圾（Floating Garbage）
收集结束时会有大量空间碎片产生

![image-20231122185233186](https://gitee.com/ycfan/images/raw/master/img/image-20231122185233186.png)