
# 内核空间和用户空间
操作系统的核心是内核，与普通的应用程序不同，它可以访问受保护的内存空间，也有访问底层硬件设备的权限。

为了避免用户进程直接操作内核，保证内核安全，操作系统将虚拟内存划分为两部分，一部分是内核空间(Kernel-space)，一部分是用户空间(User-space)。在 Linux 系统中，内核模块运行在内核空间，对应的进程处于内核态;而用户程序运行在用户空间，对应的进程处于用户态。

内核空间总是驻留在内存中，它是为操作系统的内核保留的。应用程序是不允许直接在该区域进行读写或直接调用内核代码定义的函数。

当启动某个应用程序时，操作系统会给应用程序分配一个单独的用户空间，其实就是一个用户独享的虚拟内存，每个普通的用户讲程之间的用户空间是完全隔离的、不共享的，当用户进程结束的时候，用户空间的虚拟内存也会随之释放。
同时处于用户态的进程不能访问内核空间中的数据，也不能直接调用内核函数的，如果要调用系统资源，就要将进程切换到内核态由内核程序来进行操作。
# Netty中的零拷贝实现
Netty 的零拷贝主要包含三个方面：
1. 在网络通信上，Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。
2. 在缓存操作上，Netty 提供了 CompositeBvteBuf 类，它可以将多个 ByteBuf 合并为一个逻辑上的ByteBuf，避免了各个 BvteBuf之间 的拷贝。通过wrap操作，我们可以将byte\[\]数组、BvteBuf、 BvteBuffer 等包装成一个 Netty ByteBuf对象，进而避免了拷贝操作。ByteBuf 支持 slice 操作，因此可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf，避免了内存的拷贝。
3. 在文件传输上，Netty 的通过 FileRegion 包装的 FileChannel.tranferTo 实现文件传输，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。