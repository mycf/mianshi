
零拷贝，从字面上理解，是不需要将数据从一个存储区域复制到另一个存储区域。其实，最早的零拷贝定义，来源于 Linux 系统的 sendfile 方法逻辑!

>在 Linux 2.4 内核中，sendfile 系统调用方法，可以将磁盘数据通过 DMA 拷贝到内核态 Buffer 后，再通过 DMA 拷贝到 SocketBuffer，无需 CPU 拷贝，这个过程被称之为零拷贝。

由此可见，零拷贝并不是不需要拷贝，只是说减少了冗余的不必要的拷贝。

零拷贝技术有以下两点优势:
- 零拷贝技术可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝，从而有效地提高数据传输效率;
- 零拷贝技术减少了用户态和内核态之间因为上下文切换而带来的性能开销:
常见的零拷贝方式有 mmap、sendfile 和 splice等。

# 什么是DMA?
DMA，英文全称是 Direct Memory Access，即直接内存访问。DMA 本质上是一块主板上独立的芯片，允许外设设备和内存存储器之间直接进行 IO 数据传输，其过程不需要 CPU 的参与。
# 内核空间和用户空间
操作系统的核心是内核，与普通的应用程序不同，它可以访问受保护的内存空间，也有访问底层硬件设备的权限。

为了避免用户进程直接操作内核，保证内核安全，操作系统将虚拟内存划分为两部分，一部分是内核空间(Kernel-space)，一部分是用户空间(User-space)。在 Linux 系统中，内核模块运行在内核空间，对应的进程处于内核态;而用户程序运行在用户空间，对应的进程处于用户态。

内核空间总是驻留在内存中，它是为操作系统的内核保留的。应用程序是不允许直接在该区域进行读写或直接调用内核代码定义的函数。

当启动某个应用程序时，操作系统会给应用程序分配一个单独的用户空间，其实就是一个用户独享的虚拟内存，每个普通的用户进程之间的用户空间是完全隔离的、不共享的，当用户进程结束的时候，用户空间的虚拟内存也会随之释放。

同时处于用户态的进程不能访问内核空间中的数据，也不能直接调用内核函数的，如果要调用系统资源，就要将进程切换到内核态由内核程序来进行操作。

# Java中零拷贝的实现
Linux 提供的零拷贝技术，Java 并不是全部支持，目前只支持以下2种:
- mmap(内存映射)
- sendfile
## Java NIO 对 mmap 的支持
Java NIO 有一个MappedByteBuffer的类，可以用来实现内存映射。它的底层是调用了 Linux 内核的mmap的 AP!。代码实现如下.
# kafka中的零拷贝实现
Kafka 两个重要过程都使用了零拷贝技术，一是roducer 生产的数据存到 broker，二是 Consumer 从 broker 读取数据。
Producer 生产的数据持久化到 broker，broker里采用 mmap 文件映射，实现顺序的快速写入;
Customer 从 broker 读取数据，broker 里采用sendfile，将磁盘文件读到 OS 内核缓冲区后，直接转至socket buffer 进行网络发送。
# Netty中的零拷贝实现
Netty 的零拷贝主要包含三个方面：
1. 在网络通信上，Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。
2. 在缓存操作上，Netty 提供了 CompositeBvteBuf 类，它可以将多个 ByteBuf 合并为一个逻辑上的ByteBuf，避免了各个 BvteBuf之间 的拷贝。通过wrap操作，我们可以将byte\[\]数组、BvteBuf、 BvteBuffer 等包装成一个 Netty ByteBuf对象，进而避免了拷贝操作。ByteBuf 支持 slice 操作，因此可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf，避免了内存的拷贝。
3. 在文件传输上，Netty 的通过 FileRegion 包装的 FileChannel.tranferTo 实现文件传输，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。