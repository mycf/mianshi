**tcp是面向连接的协议，它基于运输连接来传送tcp报文段

**tcp运输连接的建立和释放，是每一次面向连接的通信中必不可少的过程

**tcp运输连接有以下三个阶段**
	第一个阶段是**建立tcp连接**，也就是通过三报文握手来建立tcp连接
	第二个阶段是**数据传送**，也就是基于已建立的tcp连接进行可靠的数据传输
	第三个阶段是***释放连接***，也就是在数据传输结束后，还要通过四报文挥手来释放tcp连接
	
tcp的运输连接管理就是使运输连接的建立和释放都能正常的进行

tcp的连接建立要解决以下三个问题
使tcp双方能够确知对方的存在
使tcp双方能够协商一些参数（例如最大窗口值是否使用窗口扩大选项和时间戳选项以及服务质量等）；
使tcp双方能够对运输实体资源（例如缓存大小、连接表中的项目等进行分配）；

接下来我们就来看看tcp使用三报文握手建立连接的具体过程
这是两台要基于tcp进行通信的主机
其中一台主题中的某个应用进程主动发起tcp连接建立
称为tcp客户
另一台主机中被动等待tcp连接建立的应用进程称为tcp服务器
我们可以将tcp建立连接的过程比喻为握手
握手需要在tcp客户和服务器之间交换三个tcp报文段
最初两端的tcp进程都处于关闭状态
一开始tcp服务器进程首先创建传输控制块
用来存储tcp连接中的一些重要信息
例如tcp连接表指向发送和接收缓存的指针
指向重传队列的指针
当前发送和接收序号等
之后就准备接受tcp客户进程的连接请求
此时tcp服务器进程就要进入监听状态
等待tcp客户进程的连接请求
tcp服务器进程是被动等待来自tcp客户进程的连接请求
而不是主动发起
因此称为被动打开连接
tcp客户进程也是首先创建传输控制块
然后在打算建立tcp连接时
向tcp服务器进程发送tcp连接请求报文段
并进入同步已发送状态
tcp连接请求报文段首部中的同步位s y n被设置为一
表明这是一个tcp连接请求报文段
序号字段s e q被设置了一个初始值
x作为tcp客户进程所选择的初始序号
请注意tcp规定x y n被设置为一的报文段
不能携带数据
但要消耗掉一个序号
由于tcp连接建立是由tcp客户进程主动发起的
因此称为主动打开连接
tcp服务器进程收到tcp连接请求报文段后
如果同意建立连接
则向tcp客户进程发送tcp连接请求
确认报文段
并进入同步已接收状态
该报文段首部中的同步位s yn和确认为a c k都设置为一
表明这是一个tcp连接请求确认报文段
序号字段s e q被设置了一个初始之外
作为tcp服务器进程所选择的初始序号
确认号字段a c k的值被设置成了x加一
这是对tcp客户进程所选择的初始序号的确认
请注意
这个报文段也不能携带数据
因为它是xyn被设置为一的报文段
但同样要消耗掉一个序号
tcp客户进程收到tcp连接请求确认报文段后
还要向tcp服务器进程发送一个普通的tcp确认报文段
并进入连接已建立状态
该报文段首部中的确认问a c k被设置为一
表明这是一个普通的tcp确认报文段
序号字段s e q被设置为x加一
这是因为tcp客户进程发送的第一个tcp报文段的序号为x
并且不携带数据
因此第二个报文段的序号为x加一
请注意tcp规定
普通的tcp确认报文段可以携带数据
但如果不携带数据
则不消耗序号
在这种情况下所发送的下一个数据报文段的序号仍是x加一
确认号字段a c k被设置为y加一
这是对tcp服务器进程所选择的初始序号的确认
tcp服务器进程收到该确认报文段后也进入连接已建立状态
现在tcp双方都进入了连接已建立状态
他们可以基于已建立好的tcp连接进行可靠的数据传输了
请同学们思考这样一个问题
为什么tcp客户进程最后还要发送一个普通的tcp确认报文段呢
这是否多余
换句话说
能否使用两报文握手建立连接呢
答案是并不多余
不能简化为两报文握手
我们来举例说明
考虑这样一种情况
tcp客户进程发出一个tcp连接请求报文段
但该报文段在某些网络节点长时间滞留了
这必然会造成该报文段的超时重传
假设重传的报文段被tcp服务器进程正常接收
tcp服务器进程给tcp客户进程发送一个tcp连接请求确认报文段
并进入连接已建立状态
请注意
由于我们改为两道文握手
因此tcp服务器进程发送完tcp连接请求确认报文段后
进入的是连接已建立状态
而不像三报文握手那样进入同步已接收状态
并等待tcp客户进程发来针对tcp连接请求确认报文段的普通确认报文段
tcp客户进程收到tcp连接请求确认报文段后
进入tcp连接已建立状态
但不会给tcp服务器进程发送针对该报文段的普通确认报文段
现在tcp双方都处于连接已建立状态
他们可以相互传输数据之后可以通过四报文挥手来释放连接
tcp双方都进入了关闭状态
一段时间后
之前滞留在网络中的那个失效的tcp连接请求
报文段到达了tcp服务器进程
tcp服务器进程会误认为这是tcp客户进程又发起了一个新的tcp连接请求
于是给tcp客户进程发送tcp连接请求
确认报文段并进入连接已建立状态
该报文段到达tcp客户进程
由于tcp客户进程并没有发起新的tcp连接请求
并且处于关闭状态
因此不会理会该报文段
但tcp服务器进程已进入了连接已建立状态
他认为新的tcp连接已建立好了
并一直等待tcp客户进程发来数据
这将白白浪费tcp服务器进程所在主机的很多资源
综上所述
采用三报文握手
而不是两报文握手来建立tcp连接
是为了防止以失效的连接请求报文段突然又传送到了tcp服务器进程
因而导致错误
最后我们来做一个相关的练习题
这是计算机专业考研全国统考计算机网络部分2011年的题
39
请同学们暂停播放视频
思考一下
给出你的答案
答案是选项c
大家都选对了吗
我们来一起分析一下
如图所示
这是本节课所介绍的tcp通过三报文握手建立连接的过程
根据提议
主机甲中的是tcp客户进程
主机已中的是tcp服务器进程
这是主机甲中tcp客户进程向主机已中tcp服务器进程发送的第一个tcp段
其首部中的同部位s yn的值为一
序号字段s e q的值就是题目所给的11220
这是主机乙中tcp服务器进程给主机甲中tcp客户进程发送的tcp连接请求
确认报文段
其首部中的同步位s y n和确认为a c k的值都被设置为一
表明这是一个tcp连接请求确认报文段
确认号字段a c k的值是对主机甲中tcp客户进程所选择初始序号
11220的确认
因此为11221
至此我们就已经可以选出正确答案为选项c了
序号字段s e q的值是主机已中tcp服务器进程所选择的初始序号
可由tcp服务器进程随意指定
与其他报文段中的值无关
在本题的正确选项c中
序号字段s e q的值恰好与确认号字段a c k的值同为11221
这正是本题迷惑大家的地方
使很多同学认为该选项有点别扭
本节课到这里就结束了
我们将本节课的内容小结如下
同学们
我们下节课再见
